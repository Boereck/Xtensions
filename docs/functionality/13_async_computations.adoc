== Async Computations

Starting asynchronous computations and providing the result via a `CompletableFuture` is
provided via the JDK methods `CompletableFuture#runAsync` and `CompletableFuture#suppyAsync`.

These methods have a few drawbacks. The first one is that in Xtend it is good practice to
place the callback function as the last parameter in a parameter list to allow for more 
elegant and readable syntax, placing the lambda behind the closing parentheses. The JDK methods,
however, have overloaded versions placing a executor for operation executor as last parameter.

The other drawback is that these methods need a further concept to allow cancellation of an operation
from the caller side, e.g. when the user cancels an operation. This can e.g. be achieved via an 
additional `java.util.concurrent.atomic.AtomicBoolean` which is passed to the operation. 
This is unfortunate, since the `CompletableFuture` already knows the concept of cancellation.

This library provides the class `de.fhg.fokus.xtensions.concurrent.AsyncCompute` introducing 
the methods `asyncRun` and `asyncSupply`. These methods allow asynchronous computations
like the JDK methods, but with a shuffled parameter list and passing the created `CompletableFuture`
into the operation to be computed asynchronously.

Example using JDK classes:

[source,xtend]
----
import static java.util.concurrent.CompletableFuture.*
import java.util.concurrent.Executors
// ...
val ex = Executors.newCachedThreadPool
val isCancelled = new AtomicBoolean(false)
runAsync([
	if(isCancelled.get) {
		println("Oh no, I've been cancelled")
	} else {
		println("I'm fine")				
	}
], ex)
isCancelled.set(true)
----

Same example using `AsyncCompute`:

[source,xtend]
----
import static extension de.fhg.fokus.xtensions.concurrent.AsyncCompute.*
import java.util.concurrent.Executors
// ...
val pool = Executors.newCachedThreadPool
val fut = pool.asyncRun [
	if(cancelled) {
		println("Oh no, I've been cancelled")
	} else {
		println("I'm fine")				
	}
]
fut.cancel(false)
----